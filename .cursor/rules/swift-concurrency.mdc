---
description: "Swift 6 엄격한 동시성 패턴, actor isolation, @MainActor 사용, async/await 모범 사례, structured concurrency, Sendable 준수. 비동기 코드, actor, 동시 작업 작업 시 적용."
globs: ["Sources/**/*.swift"]
alwaysApply: false
---

# Swift Concurrency Guidelines for InnoRouter

## Actor Isolation (Swift 6 Strict Mode)

모든 코드는 Swift 6 엄격한 동시성 규칙을 따라야 합니다. 프로젝트는 `Package.swift`에 구성된 Swift 6.2 엄격한 동시성 모드를 사용합니다.

### @MainActor for NavStore and Coordinator

`NavStore`와 `Coordinator`는 UI 업데이트를 관리하므로 `@MainActor`로 격리되어 있습니다:

```swift
@Observable
@MainActor
public final class NavStore<R: Route>: Navigator {
    public var state: NavStack<R>
    public func execute(_ command: NavCommand<R>) -> NavResult<R>
}

@MainActor
public protocol Coordinator: AnyObject, Observable {
    var store: NavStore<RouteType> { get }
    func handle(_ intent: NavIntent<RouteType>)
}
```

### Navigator Protocol

`Navigator` 프로토콜도 `@MainActor`로 격리됩니다:

```swift
@MainActor
public protocol NavStateReadable: AnyObject, Sendable {
    associatedtype RouteType: Route
    var state: NavStack<RouteType> { get }
}

@MainActor
public protocol NavCommandExecuting: AnyObject, Sendable {
    associatedtype RouteType: Route
    func execute(_ command: NavCommand<RouteType>) -> NavResult<RouteType>
}

public typealias Navigator = NavStateReadable & NavCommandExecuting
```

## Sendable Conformance

### Route Types

모든 `Route` 타입은 `Sendable`을 준수해야 합니다:

```swift
public protocol Route: Hashable, Sendable {}

enum HomeRoute: Route {
    case list
    case detail(id: String)  // String은 Sendable
    case settings
}
```

### NavCommand and NavStack

네비게이션 관련 타입들은 모두 `Sendable`을 준수합니다:

```swift
public struct NavStack<R: Route>: Sendable, Equatable {
    public var path: [R]  // R은 Route이므로 Sendable
}

public indirect enum NavCommand<R: Route>: Sendable, Equatable {
    case push(R)
    case conditional(@Sendable () -> Bool, NavCommand<R>)
    // ...
}
```

### Middleware

`NavMiddleware`는 `@MainActor`에서 실행되지만 타입 자체는 `Sendable`입니다:

```swift
@MainActor
public protocol NavMiddleware: Sendable {
    associatedtype RouteType: Route
    func willExecute(_ command: NavCommand<RouteType>, state: NavStack<RouteType>) -> NavCommand<RouteType>?
    func didExecute(_ command: NavCommand<RouteType>, result: NavResult<RouteType>, state: NavStack<RouteType>)
}
```

## Deep Link Concurrency

### DeepLinkPipeline

`DeepLinkPipeline`은 `Sendable`을 준수하며 모든 클로저도 `@Sendable`입니다:

```swift
public struct DeepLinkPipeline<R: Route>: Sendable {
    public typealias Resolver = @Sendable (URL) -> R?
    public typealias Planner = @Sendable (R) -> NavPlan<R>
    
    public var resolve: Resolver
    public var requiresAuthentication: (@Sendable (R) -> Bool)?
    public var isAuthenticated: (@Sendable () -> Bool)?
    public var plan: Planner
}
```

### Deep Link Handling

딥링크 처리는 메인 스레드에서 실행되어야 합니다:

```swift
.onOpenURL { url in
    switch pipeline.decide(for: url) {
    case .plan(let plan):
        Task { @MainActor in
            for command in plan.commands {
                _ = store.execute(command)
            }
        }
    case .pending:
        // 인증 후 처리
        break
    case .rejected, .unhandled:
        break
    }
}
```

## Thread Safety

### NavigatorStorage

Environment에 저장되는 `NavigatorStorage`는 `NSLock`을 사용하여 스레드 안전하게 관리됩니다:

```swift
final class NavigatorStorage: @unchecked Sendable {
    private var navigators: [ObjectIdentifier: Any] = [:]
    private let lock = NSLock()
    
    subscript<R: Route>(routeType: R.Type) -> AnyNavigator<R>? {
        get {
            lock.lock()
            defer { lock.unlock() }
            return navigators[ObjectIdentifier(routeType)] as? AnyNavigator<R>
        }
        set {
            lock.lock()
            defer { lock.unlock() }
            navigators[ObjectIdentifier(routeType)] = newValue
        }
    }
}
```

**참고**: `@unchecked Sendable`을 사용하는 이유는 `NSLock`으로 보호되지만 컴파일러가 이를 자동으로 인식하지 못하기 때문입니다.

## Required Patterns

1. **NavStore는 @MainActor** - 모든 네비게이션 상태 업데이트는 main actor에서
2. **Coordinator는 @MainActor** - 모든 coordinator 작업은 main actor에서
3. **Sendable 준수** - Route, NavCommand, NavStack 등은 모두 Sendable
4. **@Sendable 클로저** - Middleware, DeepLinkPipeline의 클로저는 @Sendable
5. **Thread-safe storage** - NSLock을 사용한 스레드 안전 저장소
6. **Structured concurrency** - Task를 사용한 비동기 작업

## Error Handling with Concurrency

딥링크 처리나 비동기 작업에서 에러가 발생할 수 있는 경우:

```swift
Task { @MainActor in
    do {
        let route = try await resolveDeepLink(url)
        _ = store.execute(.push(route))
    } catch {
        // 에러 처리
        handleError(error)
    }
}
```

## Migration from GCD

프레임워크 내부에서는 GCD를 사용하지 않고 Swift Concurrency만 사용합니다:

```swift
// ❌ 사용하지 않음: GCD
DispatchQueue.main.async { ... }

// ✅ 사용: Swift Concurrency
Task { @MainActor in
    // ...
}
```

## @unchecked Sendable

`NavStore`는 `@unchecked Sendable`을 사용합니다:

```swift
@Observable
@MainActor
public final class NavStore<R: Route>: Navigator, @unchecked Sendable {
    // ...
}
```

이유:
- `@Observable` 매크로가 생성하는 코드가 `Sendable`을 자동으로 준수하지 않음
- 실제로는 `@MainActor`로 격리되어 있어 안전함
- `@unchecked Sendable`로 명시적으로 표시

모든 동시성 코드는 이러한 엄격한 동시성 가이드라인을 따라야 합니다.
